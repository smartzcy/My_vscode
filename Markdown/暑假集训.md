# 暑假集训

## 分块+莫队

### 分块

#### 简介

- 分块是一种思想，而不是一种数据结构。

- 分块的基本思想是：通过对原数据的适当划分，并在划分后的每一个块上预处理部分信息，从而较一般的暴力算法取得更优的时间复杂度。

- 分块的时间复杂度主要取决于分块的块长，一般可以通过均值不等式求出某个问题下的最优块长，以及相应的时间复杂度。

- 分块是一种很灵活的思想，相较于树状数组和线段树，分块的优点是通用性更好，可以维护很多树状数组和线段树无法维护的信息。

- 当然，分块的缺点是渐进意义的复杂度，相较于线段树和树状数组不够好

#### 例题

已知一个数列，你需要进行下面两种操作：洛谷 P3372

1. 将某区间每个数加上 $k$ 。

2. 求出某区间每一个数的和。

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
const int INF = 1e9;
const int N = 2e5 + 10;
long long n, m, B;
long long a[N], id[N], l[N], r[N], sum[N], tag[N];
void build() {
    for (int i = 1; i <= n; i++) id[i] = (i - 1) / B + 1;
    for (int i = 1; i <= id[n]; i++) l[i] = (i - 1) * B + 1, r[i] = min(i * B, n);
    for (int i = 1; i <= n; i++) sum[id[i]] += a[i];
}
void bf_modify(int ql, int qr, int x) {
    for (int i = ql; i <= qr; i++) a[i] += x;
    sum[id[ql]] += (qr - ql + 1) * x;
}
long long bf_query(int ql, int qr) {
    long long ans = 0;
    ans += (qr - ql + 1) * tag[id[ql]];
    for (int i = ql; i <= qr; i++) ans += a[i];
    return ans;
}
void modify(int ql, int qr, int x) {
    int lid = id[ql], rid = id[qr];
   if (lid == rid) {
        bf_modify(ql, qr, x);
        return;
    }
    bf_modify(ql, r[lid], x);
    for (int i = lid + 1; i <= rid - 1; i++) tag[i] += x;
    bf_modify(l[rid], qr, x);
}
long long query(int ql, int qr) {
    int lid = id[ql], rid = id[qr];
    if (lid == rid) {
        return bf_query(ql, qr);
    }
    long long ans = 0;
    ans += bf_query(ql, r[lid]);
    for (int i = lid + 1; i <= rid - 1; i++) ans += tag[i] * (r[i] - l[i] + 1) + sum[i];
    ans += bf_query(l[rid], qr);
    return ans;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    B = sqrt(n);
    build();
    while (m--) {
        int k, x, y, z;
        cin >> k >> x >> y;
        if (k == 1) {
            cin >> z;
            modify(x, y, z);
        } else {
            cout << query(x, y) << endl;
        }
    }
    return 0;
}
```

给出一个长为 n 的数列，以及 n 个操作，操作涉及区间加法，询问区间内小于某个值 x 的元素个数。

第一行输入一个数字 n。

第二行输入 n 个数字，第 i 个数字为 ai​，以空格隔开。

接下来输入 n 行询问，每行输入四个数字 opt、l、r、c，以空格隔开。

若 opt=0，表示将位于 [l,r] 的之间的数字都加 c。

若 opt=1，表示询问 [l,r] 中，小于 c2 的数字的个数。

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
using namespace std;
const int INF = 1e9;
const int N = 1e5 + 10;
int n, m, B;
int a[N], id[N], tag[N], ql[N], qr[N];
vector<int> vec[N];
void build() {
    for (int i = 1; i <= n; i++) id[i] = (i - 1) / B + 1, vec[id[i]].push_back(a[i]);
    for (int i = 1; i <= id[n]; i++) ql[i] = (i - 1) * B + 1, qr[i] = i * B, sort(vec[i].begin(), vec[i].end());
}
void bf_modify(int l, int r, int x) {
    for (int i = l; i <= r; i++) a[i] += x;
    int lid = id[l];
    vec[lid].clear();
    for (int i = ql[lid]; i <= qr[lid]; i++) {
        vec[lid].push_back(a[i]);
    }
    sort(vec[lid].begin(), vec[lid].end());
}
void modify(int l, int r, int x) {
    int lid = id[l], rid = id[r];
    if (lid == rid) {
        bf_modify(l, r, x);
        return;
    }
    bf_modify(l, qr[lid], x);
    for (int i = lid + 1; i <= rid - 1; i++) tag[i] += x;
    bf_modify(ql[rid], r, x);
}
int bf_query(int l, int r, int c) {
    int ans = 0;
    for (int i = l; i <= r; i++) {
        if (a[i] + tag[id[l]] < c) ans++;
    }
    return ans;
}
int query(int l, int r, int c) {
    int ans = 0;
    int lid = id[l], rid = id[r];
    if (lid == rid) {
        for (int i = l; i <= r; i++) {
            if (a[i] + tag[lid] < c) ans++;
        }
        return ans;
    }
    ans += bf_query(l, qr[lid], c);
    for (int i = lid + 1; i <= rid - 1; i++) {
        ans += (lower_bound(vec[i].begin(), vec[i].end(), c - tag[i]) - vec[i].begin());
    }
    ans += bf_query(ql[lid], r, c);
    return ans;
}
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    B = sqrt(n);
    build(); // 没写
    for (int i = 1; i <= n; i++) {
        int opt, l, r, c;
        cin >> opt >> l >> r >> c;
        if (!opt)
            modify(l, r, c);
        else
            cout << query(l, r, c * c) << endl;
    }
}
```

### 莫队

#### 简介

莫队算法是由莫涛（当初是OI中国队队长）提出的算法，因此被称为莫队算法。在莫涛提出莫队算法之前，莫队算法已经在 Codeforces 的高手圈里小范围流传，但是莫涛是第一个对莫队算法进行详细归纳总结的人，现在在国际上也是讲其称为“Mo‘s algorithm”。莫涛提出莫队算法时，只分析了普通莫队（顺序数据结构，不支持修改）算法，但是经过 OIer 和 ACMer 的集体智慧改造，莫队有了多种扩展版本。
莫队算法可以解决一类离线区间询问问题，适用性极为广泛。同时将其加以扩展，便能轻松处理树上路径询问以及支持修改操作。

对于关于一个序列的区间询问，如果满足以下两个条件：

1. 能从 区间【l,r】 的答案O ( 1 ) 扩展到区间【l-1，r】，【l+1,r】，【l,r-1】，【l,r+1】 （即与相邻的区间）的答案
2. 询问可以被离线处理

那么在n（序列长度）和m（询问次数）同阶的情况下，将序列以$ \sqrt n $​ 为长度进行分块，则对于序列上的区间询问问题，可以在 $O(n ∗ \sqrt n)$ 的时间复杂度内求出所有询问的答案。
在n（序列长度）和m（询问次数）不同阶的情况下，将序列**以$n /  \sqrt  
m$为长度**进行分块，则对于序列上的区间询问问题，可以在 $O(n ∗\sqrt  
m)$的时间复杂度内求出所有询问的答案。

莫队算法的基本思想为分块，精髓在于对询问进行排序，即对所有的区间询问’【 l , r 】 【l,r】【l,r】 , 以 $l$ 所在块的编号为第一关键字， $r$ 为第二关键字从小到大排序。
排序后对所有询问顺序处理，即从上一次询问的答案扩展得到下一次询问。

#### 例题

洛谷 P2709

小B有一个长为 $n$ 的整数序列 a ，值域为 $[l , r]$ 。他一共有m个询问，每个询问给定一个区间$[l,r]$ ，求：$\sum_{i = 1}^{k}{c_i^2}$ 其中$c_i$ 表示数字 $i$ 在$[l,r]$ 中的出现次数。

题解:

1. 询问显然可以离线处理。

2. 区间【l,r】转移到相邻区间会使得区间发生以下情况 增加一个数字，假设为X，则答案增加$(x  + 1) ^ 2 - x^2=2*x+1 $ 减少一个数字，假设为$X$，则答案减少$x^2-(x-1)^2=2*x-1$

```cpp
#include <bits/stdc++.h>
#define N 50005
#define ll long long
using namespace std;
struct Query {
    int l, r, id, pos;
    bool operator<(const Query &x) const {
        if (pos == x.pos)
            return r < x.r;
        else
            return pos < x.pos;
    }
} query[N];
int num[N], n, m, K;
ll cnt[N], Ans[N];
ll ans = 0;
// 把区间改变对答案所造成的影响推出来，
// 然后对add和del进行相应修改即可
void add(int x) {
    ans += 2 * cnt[x] + 1;
    cnt[x]++;
}
void del(int x) {
    ans -= 2 * cnt[x] - 1;
    cnt[x]--;
}
int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> m >> K;
    int size = (int)sqrt(n);
    for (int i = 1; i <= n; i++)
        cin >> num[i];
    // 读入并排序询问
    for (int i = 1; i <= m; i++) {
        cin >> query[i].l >> query[i].r;
        query[i].id = i;
        query[i].pos = (query[i].l - 1) / size + 1;
    }
    sort(query + 1, query + m + 1);
    // 离线处理询问
    int l = 1, r = 0;
    for (int i = 1; i <= m; i++) {
        while (l > query[i].l) // l需要往左移，区间增大
            add(num[--l]);
        while (r < query[i].r) // r需要往右移，区间增大
            add(num[++r]);
        while (l < query[i].l) // l需要往右移动，区间缩小
            del(num[l++]);
        while (r > query[i].r) // r需要往左移，区间缩小
            del(num[r--]);
        Ans[query[i].id] = ans;
    }
    for (int i = 1; i <= m; i++)
        cout << Ans[i] << '\n';
    return 0;
}
```

洛谷 P1494

作为一个生活散漫的人，小 Z 每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小 Z 再也无法忍受这恼人的找袜子过程，于是他决定听天由命……

具体来说，小 Z 把这 $N$ 只袜子从 1 到 N 编号，然后从编号 L 到 R (L 尽管小 Z 并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。

你的任务便是告诉小 Z，他有多大的概率抽到两只颜色相同的袜子。当然，小 Z 希望这个概率尽量高，所以他可能会询问多个 (L,R) 以方便自己选择。

**然而数据中有 L=R 的情况，请特判这种情况，输出`0/1`。**

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
typedef long long LL;
const int maxn = 50005;
int n, m, pos[maxn], c[maxn];
LL s[maxn], ans;
struct Data {
    int l, r, id;
    LL a, b;
} a[maxn];
bool cmp(const Data &a, const Data &b) {
    if (pos[a.l] == pos[b.l])
        return a.r < b.r;
    return a.l < b.l;
}
bool cmp_id(const Data &a, const Data &b) {
    return a.id < b.id;
}
void update(int p, int add) {
    ans -= s[c[p]] * s[c[p]];
    s[c[p]] += add;
    ans += s[c[p]] * s[c[p]];
}
void solve() {
    for (int i = 1, l = 1, r = 0; i <= m; i++) {
        for (; r < a[i].r; r++)
            update(r + 1, 1);
        for (; r > a[i].r; r--)
            update(r, -1);
        for (; l < a[i].l; l++)
            update(l, -1);
        for (; l > a[i].l; l--)
            update(l - 1, 1);
        if (a[i].l == a[i].r) {
            a[i].a = 0;
            a[i].b = 1;
            continue;
        }
        a[i].a = ans - (a[i].r - a[i].l + 1);
        a[i].b = (a[i].r - a[i].l + 1) * 1LL * (a[i].r - a[i].l);
        LL g = __gcd(a[i].a, a[i].b);
        a[i].a /= g;
        a[i].b /= g;
    }
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d", &c[i]);
    int block = sqrt(n);
    for (int i = 1; i <= n; i++)
        pos[i] = (i - 1) / block + 1;
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &a[i].l, &a[i].r);
        a[i].id = i;
    }
    sort(a + 1, a + m + 1, cmp);
    solve();
    sort(a + 1, a + m + 1, cmp_id);
    for (int i = 1; i <= m; i++)
        printf("%lld/%lld\n", a[i].a, a[i].b);
    return 0;
}
```

## 扫描线

求二维平面内 去一个区间有几个点

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <array>
using namespace std;
const int INF = 1e9;
const int N = 5e5 + 10;
int n, q;
int c[N];
vector<int> nums;
vector<array<int, 2>> vs;
vector<array<int, 4>> event;
vector<array<int, 8>> query;
array<int, 4> ans[N];
int lowbit(int x) {
    return x & -x;
}
void add(int x) {
    for (int i = x; i < N; i += lowbit(i)) c[i]++;
}
int sum(int x) {
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) res += c[i];
    return res;
}
int find(int x) {
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin() + 1;
};
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n >> q;
    for (int i = 1; i <= n; i++) {
        int x, y;
        cin >> x >> y;
        vs.push_back({x, y});
        nums.push_back(x);
    }
    for (int i = 1; i <= q; i++) {
        int x1, x2, y1, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        query.push_back({x2, y2, x1 - 1, y2, x2, y1 - 1, x1 - 1, y1 - 1});
        nums.push_back(x1 - 1);
        nums.push_back(x2);
    }
    sort(nums.begin(), nums.end());
    nums.erase(unique(nums.begin(), nums.end()), nums.end());
    for (auto &xx : vs) {
        int x = xx[0];
        int y = xx[1];
        x = find(x);
        event.push_back({y, -1, -1, x});
    }
    for (int i = 0; i < q; i++) {
        int x1 = query[i][0], y1 = query[i][1];
        int x2 = query[i][2], y2 = query[i][3];
        int x3 = query[i][4], y3 = query[i][5];
        int x4 = query[i][6], y4 = query[i][7];
        x1 = x3 = find(x1);
        x2 = x4 = find(x2);
        event.push_back({y1, i, 0, x1});
        event.push_back({y2, i, 1, x2});
        event.push_back({y3, i, 2, x3});
        event.push_back({y4, i, 3, x4});
    }
    sort(event.begin(), event.end());
    for (auto &xx : event) {
        int y = xx[0];
        int id = xx[1];
        int pos = xx[2];
        int x = xx[3];
        if (id == -1) {
            add(x);
        } else {
            ans[id][pos] = sum(x);
        }
    }
    for (int i = 0; i < q; i++) {
        cout << ans[i][0] - ans[i][1] - ans[i][2] + ans[i][3] << endl;
    }
}
```

二维矩形面积求并

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <array>
using namespace std;
typedef long long ll;
const int maxn = 100100;
int n;
vector<int> nums;
vector<array<int, 4>> evt;
struct info {
    int minv, cnt;
};
struct node {
    int t;
    info val;
} seg[maxn * 8];
info operator+(const info &ls, const info &rs) {
    info rt;
    rt.minv = min(ls.minv, rs.minv);
    if (ls.minv < rs.minv)
        rt.cnt = ls.cnt;
    else if (ls.minv > rs.minv)
        rt.cnt = rs.cnt;
    else
        rt.cnt = ls.cnt + rs.cnt;
    return rt;
}
void settag(int id, int t) {
    seg[id].val.minv += t;
    seg[id].t += t;
}
void up(int id) {
    seg[id].val = seg[id * 2].val + seg[id * 2 + 1].val;
}
void down(int id) {
    if (seg[id].t) {
        settag(id * 2, seg[id].t);
        settag(id * 2 + 1, seg[id].t);
        seg[id].t = 0;
    }
}
void build(int id, int l, int r) {
    if (l == r) {
        seg[id] = {0, (info){0, nums[r] - nums[r - 1]}};
        return;
    }
    int mid = (l + r) / 2;
    build(id * 2, l, mid);
    build(id * 2 + 1, mid + 1, r);
    up(id);
}
void modify(int id, int l, int r, int ql, int qr, int val) {
    if (ql == l && qr == r) {
        settag(id, val);
        return;
    }
    down(id);
    int mid = (l + r) / 2;
    if (qr <= mid)
        modify(id * 2, l, mid, ql, qr, val);
    else if (ql > mid)
        modify(id * 2 + 1, mid + 1, r, ql, qr, val);
    else {
        modify(id * 2, l, mid, ql, mid, val);
        modify(id * 2 + 1, mid + 1, r, mid + 1, qr, val);
    }
    up(id);
}
int find(int x) {
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
};
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int x1, x2, y1, y2;
        // cin >> x1 >> x2 >> y1 >> y2;
        cin >> x1 >> y1 >> x2 >> y2;
        if (x1 == x2 || y1 == y2) continue;
        evt.push_back({x1, 1, y1, y2});
        evt.push_back({x2, -1, y1, y2});
        nums.push_back(y1);
        nums.push_back(y2);
    }
    sort(nums.begin(), nums.end());
    nums.erase(unique(nums.begin(), nums.end()), nums.end());
    sort(evt.begin(), evt.end());
    int m = nums.size() - 1;
    build(1, 1, m);
    int prex = 0, len = seg[1].val.cnt; // 总长度
    ll ans = 0;
    for (auto [x, ty, l, r] : evt) {
        int cov = len;
        if (!seg[1].val.minv) cov -= seg[1].val.cnt; // 如果最小值>0，说明全都被矩形覆盖了
        ans += 1ll * (x - prex) * cov;               // 长乘宽
        l = find(l) + 1;                             // 用l+1这个点表示[l, l + 1]这段长度
        r = find(r);
        modify(1, 1, m, l, r, ty);
        prex = x;
    }
    cout << ans;
}
```

你将得到 n 条一维线段，我们定义一个点是特殊的如果它所在的位置处于至少 k 条线段的位置区间中（包括两端），规定若干连续的特殊点能够组成一条线段，请输出所有由特殊点组成的线段的位置区间，也即线段两端 [L,R] 。并将其按照左端点排序、

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
const int INF = 1e9;
const int N = 1e5 + 10;
int n, k, now = 0, lid = 0, flag = 0;
vector<pair<int, int>> vec, ans;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        int l, r;
        cin >> l >> r;
        vec.push_back({l, 1});
        vec.push_back({r + 1, -1});
    }
    sort(vec.begin(), vec.end());
    for (auto &[v, typ] : vec) {
        now += typ;
        if (now >= k) {
            if (!flag) lid = v;
            flag = 1;
        } else if (flag) {
            ans.push_back({lid, v - 1});
            flag = 0;
        }
    }
    cout << ans.size() << endl;
    for (auto &[x, y] : ans) cout << x << " " << y << endl;
}
```

## 可持久化线段树

这是个非常经典的可持久化权值线段树入门题——静态区间第 k 小。洛谷P3834

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
const int INF = 1e9;
const int N = 2e5 + 100;
int n, q, tot;
vector<int> vec;
int a[N], rt[N];
int ls[N * 100], rs[N * 100], sum[N * 100];
void change(int &rt, int pre, int l, int r, int pos) {
    rt = ++tot;
    ls[rt] = ls[pre], rs[rt] = rs[pre], sum[rt] = sum[pre] + 1;
    if (l == r)
        return;
    int mid = l + r >> 1;
    if (pos <= mid)
        change(ls[rt], ls[pre], l, mid, pos);
    else
        change(rs[rt], rs[pre], mid + 1, r, pos);
}
int query(int rt, int pre, int l, int r, int k) {
    if (l == r) return l;
    int cnt = sum[ls[rt]] - sum[ls[pre]];
    int mid = l + r >> 1;
    if (cnt >= k) return query(ls[rt], ls[pre], l, mid, k);
    return query(rs[rt], rs[pre], mid + 1, r, k - cnt);
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> q;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        vec.push_back(a[i]);
    }
    sort(vec.begin(), vec.end());
    vec.erase(unique(vec.begin(), vec.end()), vec.end());
    for (int i = 1; i <= n; i++) {
        int k = lower_bound(vec.begin(), vec.end(), a[i]) - vec.begin() + 1;
        change(rt[i], rt[i - 1], 1, n, k);
    }
    while (q--) {
        int l, r, k;
        cin >> l >> r >> k;
        cout << vec[query(rt[r], rt[l - 1], 1, n, k) - 1] << endl;
    }
}
```

有一次，小明在左口袋中发现了一个由 *n* 个整数组成的数组，并在右口袋中找到了 *q* 个形式为 *l* *r* *k* 的查询。如果有查询，则必须回答。查询的答案是最小的 *x* 使得*x* 出现在区间 *l* *r* 严格超过$ \frac{r - l + 1}{k}$ 次数或  - 1 如果没有这样的数字。帮助小明完成如此艰巨的任务。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>
using namespace std;
const int INF = 1e9;
const int N = 3e5 + 100;
int n, q, tot, ans;
vector<int> vec;
int a[N], rt[N];
int ls[N * 100], rs[N * 100], sum[N * 100];
void change(int &rt, int pre, int l, int r, int pos) {
    rt = ++tot;
    ls[rt] = ls[pre], rs[rt] = rs[pre], sum[rt] = sum[pre] + 1;
    if (l == r)
        return;
    int mid = l + r >> 1;
    if (pos <= mid)
        change(ls[rt], ls[pre], l, mid, pos);
    else
        change(rs[rt], rs[pre], mid + 1, r, pos);
}
void query(int rt, int pre, int l, int r, int k) {
    if (l == r) {
        if (sum[rt] - sum[pre] > k && (ans == -1 || ans > l)) {
            ans = l;
        }
        return;
    }
    int cnt = sum[rt] - sum[pre];
    int mid = l + r >> 1;
    if (cnt > k) {
        query(ls[rt], ls[pre], l, mid, k);
        query(rs[rt], rs[pre], mid + 1, r, k);
    }
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> q;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        change(rt[i], rt[i - 1], 1, n, a[i]);
    }
    while (q--) {
        int l, r, k;
        cin >> l >> r >> k;
        ans = -1;
        query(rt[r], rt[l - 1], 1, n, (r - l + 1) / k);
        cout << ans << endl;
    }
}
```

## 状压DP

题意：有n道题目，每道题目有两个值，a，b。若 你在 t 分钟时做了某道题，那么你会获得 a * t + b的分数。但是做某道题时，有限制条件，你想要先做完了另外一些题目才能做这道题。比如 在做第三题时，第三题要求必须先做完第一题和 第二题，那么你要想做第三题 必须先做完第一题和第二题，问如何做题才能最后分数最大。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;
const int INF = 1e9;
const int N = 2e6 + 10;
long long n, m, k, ans = 0;
long long a[31], b[31], c[31], dp[N];
long long check(long long x) {
    long long an = 0;
    while (x) {
        an++;
        x &= (x - 1);
    }
    return an;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i] >> b[i] >> k;
        c[i] = 0;
        for (int j = 0, x; j < k; j++) {
            cin >> x;
            x--;
            c[i] |= (1 << x);
        }
    }
    m = 1 << n;
    for (int i = 0; i <= m; i++) dp[i] = -INF;
    dp[0] = 0;
    for (int i = 1; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i & (1 << j)) {
                long long tmp = i ^ (1 << j);
                if (dp[tmp] == -INF) continue;
                if ((tmp | c[j]) == tmp) {
                    int time = check(i);
                    dp[i] = max(dp[i], dp[tmp] + a[j] * time + b[j]);
                    ans = max(ans, dp[i]);
                }
            }
        }
    }
    cout << ans << endl;
}
```

N 皇后是一个经典的搜索问题。今天我们尝试解决 N 国王问题。不同于手长的皇后，国王只能攻击到与自己八连通的位置，即上、下、左、右四个位置和左上、左下、右上、右下四个位置。

在 n×n 的棋盘里面放 k 个国王，使他们互不攻击，输出可行的方案数量。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;
const int INF = 1e9;
const int N = 2e3 + 10;
long long n, k, cnt[N], tot, st[N];
long long dp[11][100][N];
int main() {
    cin >> n >> k;
    for (int i = 0; i < (1 << n); i++) {
        int s1 = i, num = 0;
        while (s1) {
            num++;
            s1 &= (s1 - 1);
        }
        cnt[i] = num;
        if (!((i << 1) & i || (i >> 1) & i)) st[tot++] = i;
    }
    dp[0][0][0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int now = 0; now < tot; now++) {
            int s1 = st[now];
            for (int pre = 0; pre < tot; pre++) {
                int s2 = st[pre];
                if ((s2 << 1) & s1 || (s2 >> 1) & s1 || s2 & s1) continue;
                for (int j = 0; j <= k; j++) {
                    if (j - cnt[s1] >= 0)
                        dp[i][j][s1] += dp[i - 1][j - cnt[s1]][s2];
                }
            }
        }
    }
    long long ans = 0;
    for (int j = 0; j < tot; j++) {
        ans += dp[n][k][st[j]];
    }
    cout << ans << endl;
}
```

## 区间DP

在一个圆形操场的四周摆放 N 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 2 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。

试设计出一个算法,计算出将 N 堆石子合并成 1 堆的最小得分和最大得分。

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;
int a[200], n;
int f[200][200] = {0};
int fx[200][200] = {0};
int pre[200] = {0};
int ans_max = -1;
int ans_min = 0x7f7f7f7f;
int main() {
    int i, l, k;
    scanf("%d", &n);
    for (i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        a[n + i] = a[i];
    }
    int len = (n << 1) - 1;
    for (i = 1; i <= len; i++) {
        pre[i] = pre[i - 1] + a[i];
    }
    memset(fx, 0x7f7f, sizeof(fx));
    for (i = 0; i <= 200; i++) fx[i][i] = 0;
    for (i = 2; i <= n; i++) {
        for (l = 1; l <= len - i + 1; l++) {
            int r = l + i - 1;
            for (k = l; k < r; k++) {
                f[l][r] = max(f[l][r], f[l][k] + f[k + 1][r]);
                fx[l][r] = min(fx[l][r], fx[l][k] + fx[k + 1][r]);
            }
            f[l][r] += pre[r] - pre[l - 1];
            fx[l][r] += pre[r] - pre[l - 1];
        }
    }
    for (i = 1; i <= n; i++) {
        ans_max = max(ans_max, f[i][i + n - 1]);
        ans_min = min(ans_min, fx[i][i + n - 1]);
    }
    printf("%d\n", ans_min);
    printf("%d", ans_max);
    return 0;
}
```

## 期望DP

We have a bag containing A gold coins, B silver coins, and C bronze coins.

Until the bag contains 100 coins of the same color, we will repeat the following operation:

Operation: Randomly take out one coin from the bag. (Every coin has an equal probability of being chosen.) Then, put back into the bag two coins of the same kind as the removed coin.

Find the expected value of the number of times the operation is done.

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;
const int INF = 1e9;
const int N = 1e5 + 10;
int A, B, C;
double dp[110][110][110];
double dfs(int x, int y, int z) {
    if (x >= 100 || y >= 100 || z >= 100) return 0;
    if (dp[x][y][z] > 0) return dp[x][y][z];
    dp[x][y][z] = 1.0;
    dp[x][y][z] += 1.0 * x / (x + y + z) * dfs(x + 1, y, z);
    dp[x][y][z] += 1.0 * y / (x + y + z) * dfs(x, y + 1, z);
    dp[x][y][z] += 1.0 * z / (x + y + z) * dfs(x, y, z + 1);
    return dp[x][y][z];
}
int main() {
    cin >> A >> B >> C;
    printf("%.10f\n", dfs(A, B, C));
}
```

## 博弈论

打表

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
#include <map>
using namespace std;
const int INF = 1e9;
const int N = 1e3 + 10;
int n, m, tot = 1;
int op[N], sg[N], flag[N];
void init() {
    op[1] = 1;
    tot = 1;
    for (int i = 2;; i++) {
        op[i] = op[i - 1] * 2;
        tot = i;
        if (op[i] > N) break;
    }
}
void get_sg() {
    sg[0] = 0;
    for (int i = 1; i < N; i++) {
        memset(flag, 0, sizeof(flag));
        for (int j = 1; j <= tot && op[j] <= i; j++) flag[sg[i - op[j]]] = 1;
        for (int j = 0; j < N; j++) {
            if (!flag[j]) {
                sg[i] = j;
                break;
            }
        }
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    init();
    get_sg();
    while (cin >> n) {
        if (sg[n])
            cout << "Kiki" << endl;
        else
            cout << "Cici" << endl;
    }
}
```

Siri is playing a two-player mini-game, and he called Dagu to play the game with him.

The whole game flow is as follows: n piles of stones will be randomly generated at the beginning of the game, and there are ai​ stones in the i th pile. At the same time, the players will set a lucky number p. The two players then take turns to perform the following operation: choose a pile and remove some stones from the pile. The number of stones removed each time must be a non-negative integer power of the lucky number. That is, the number of stones that both players can remove each time is a set as {1,p,p2...}. Specially, if p=1 , both player can only remove one stone each time. Like many games, whenever a player cannot perform any operation, that player loses.

Siri, as the king of mini-games, wants to humiliate Dagu, but he is busy falling in love with his girlfriend, so he found you and wanted to know if he would win ultimately, when Siri goes first and both players play optimally?

打表找规律

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
#include <map>
using namespace std;
const int INF = 1e9;
const int N = 1e3 + 10;
long long n, m;
int main() {
    cin >> n >> m;
    int cnt = 0;
    for (long long i = 1, a; i <= n; i++) {
        cin >> a;
        if (m % 2 == 0) {
            if ((a - m) % (m + 1) == 0)
                cnt ^= 2;
            else
                cnt ^= !(((a + 1) % (m + 1)) % 2);
        } else {
            cnt ^= a % 2;
        }
    }
    if (!cnt)
        cout << "BAD" << endl;
    else
        cout << "GOOD" << endl;
}
/*
m % 2 == 0
2 : m + (m + 1)k
(n + 1) % (m + 1) % 2 ? 0 : 1

m % 2 == 1
n % 2
*/
```

## 数论分块 + 容斥原理

求因数

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;
const int INF = 1e9;
const int N = 1e5 + 10;
int n, m;
int main() {
    cin >> n;
    for (int l = 1, r; l <= n; l = r + 1) {
        r = n / (n / l);
        m += (n / l) * (r - l + 1);
    }
    cout << m << endl;
}
```

约数和

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;
const int INF = 1e9;
const int N = 1e5 + 10;
long long n, m, ans;
long long solve(long long n) {
    long long i = 1, tot = 0;
    while (i <= n) {
        int j = n / (n / i);
        tot += n / i * (i + j) * (j - i + 1) / 2;
        i = j + 1;
    }
    return tot;
}
int main() {
    cin >> n >> m;
    cout << solve(m) - solve(n - 1) << endl;
}
```

## Tarjan

给定一个 n 个点 m 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。

允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5e5 + 5;
const int maxm = 2e6 + 5;
typedef long long ll;
int n, m;
int idx = 0, sccnt = 0, top = 0;
vector<pair<int, int>> e;
int dfn[maxn], low[maxn], scc[maxn], sta[maxn];
int etot = 0;
struct edge {
    int y, nxt;
} g[maxm];
int head[maxn];
void add(int x, int y) {
    ++etot;
    g[etot].y = y;
    g[etot].nxt = head[x];
    head[x] = etot;
}
void tarjan(int x) {
    dfn[x] = low[x] = ++idx;
    sta[++top] = x;
    for (int i = head[x]; i; i = g[i].nxt) {
        int y = g[i].y;
        if (!dfn[y]) {
            tarjan(y);
            low[x] = min(low[x], low[y]);
        } else if (!scc[y])
            low[x] = min(low[x], low[y]);
    }
    if (dfn[x] == low[x]) {
        sccnt++;
        while (sta[top] != x) {
            scc[sta[top]] = sccnt;
            top--;
        }
        scc[sta[top]] = sccnt;
        top--;
    }
}
set<pair<int, int>> qc;
vector<ll> G[maxn];
ll a[maxn], v[maxn], du[maxn], ans[maxn];
signed main() {
    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        e.push_back({x, y});
        add(x, y);
    }
    for (int i = 1; i <= n; i++)
        if (!dfn[i]) tarjan(i);
    for (int i = 1; i <= n; i++) v[scc[i]] += a[i];
    for (int i = 0; i < e.size(); i++) {
        int x = e[i].first, y = e[i].second;
        x = scc[x];
        y = scc[y];
        if (x == y || x == 0 || y == 0) continue;
        if (qc.count({x, y}) == 0) {
            qc.insert({x, y});
            G[x].push_back(y);
            du[y]++;
        }
    }
    queue<ll> q;
    for (int i = 1; i <= sccnt; i++) {
        if (du[i] == 0) {
            q.push(i);
            ans[i] = v[i];
        }
    }
    while (q.size()) {
        ll x = q.front();
        q.pop();
        for (int y : G[x]) {
            ans[y] = max(ans[x] + v[y], ans[y]);
            du[y]--;
            if (!du[y]) q.push(y);
        }
    }
    ll mx = 0;
    for (int i = 1; i <= sccnt; i++) mx = max(mx, ans[i]);
    cout << mx << "\n";
}
```

满汉全席是中国最丰盛的宴客菜肴，有许多种不同的材料透过满族或是汉族的料理方式，呈现在数量繁多的菜色之中。由于菜色众多而繁杂，只有极少数博学多闻技艺高超的厨师能够做出满汉全席，而能够烹饪出经过专家认证的满汉全席，也是中国厨师最大的荣誉之一。世界满汉全席协会是由能够料理满汉全席的专家厨师们所组成，而他们之间还细分为许多不同等级的厨师。

为了招收新进的厨师进入世界满汉全席协会，将于近日举办满汉全席大赛，协会派遣许多会员当作评审员，为的就是要在参赛的厨师之中，找到满汉界的明日之星。

大会的规则如下：每位参赛的选手可以得到 n 种材料，选手可以自由选择用满式或是汉式料理将材料当成菜肴。

大会的评审制度是：共有 m 位评审员分别把关。每一位评审员对于满汉全席有各自独特的见解，但基本见解是，要有两样菜色作为满汉全席的标志。如某评审认为，如果没有汉式东坡肉跟满式的涮羊肉锅，就不能算是满汉全席。但避免过于有主见的审核，大会规定一个评审员除非是在认为必备的两样菜色都没有做出来的状况下，才能淘汰一位选手，否则不能淘汰一位选手。

换句话说，只要参赛者能在这两种材料的做法中，其中一个符合评审的喜好即可通过该评审的审查。如材料有猪肉，羊肉和牛肉时，有四位评审员的喜好如下表：

```undefined
评审一 评审二 评审三 评审四 
满式牛肉 满式猪肉 汉式牛肉 汉式牛肉 
汉式猪肉 满式羊肉 汉式猪肉 满式羊肉 
```

如参赛者甲做出满式猪肉，满式羊肉和满式牛肉料理，他将无法满足评审三的要求，无法通过评审。而参赛者乙做出汉式猪肉，满式羊肉和满式牛肉料理，就可以满足所有评审的要求。

但大会后来发现，在这样的制度下如果材料选择跟派出的评审员没有特别安排好的话，所有的参赛者最多只能通过部分评审员的审查而不是全部，所以可能会发生没有人通过考核的情形。

如有四个评审员喜好如下表时，则不论参赛者采取什么样的做法，都不可能通过所有评审的考核：

```undefined
评审一 评审二 评审三 评审四 
满式羊肉 满式猪肉 汉式羊肉 汉式羊肉 
汉式猪肉 满式羊肉 汉式猪肉 满式猪肉 
```

所以大会希望有人能写一个程序来判断，所选出的 m 位评审，会不会发生没有人能通过考核的窘境，以便协会组织合适的评审团。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5e5 + 5;
const int maxm = 2e6 + 5;
int n, m;
int idx = 0, sccnt = 0, top = 0;
vector<pair<int, int>> e;
int dfn[maxn], low[maxn], scc[maxn], sta[maxn];
int etot = 0;
struct edge {
    int y, nxt;
} g[maxm];
int head[maxn];
void add(int x, int y) {
    ++etot;
    g[etot].y = y;
    g[etot].nxt = head[x];
    head[x] = etot;
}
void tarjan(int x) {
    dfn[x] = low[x] = ++idx;
    sta[++top] = x;
    for (int i = head[x]; i; i = g[i].nxt) {
        int y = g[i].y;
        if (!dfn[y]) {
            tarjan(y);
            low[x] = min(low[x], low[y]);
        } else if (!scc[y])
            low[x] = min(low[x], low[y]);
    }
    if (dfn[x] == low[x]) {
        sccnt++;
        while (sta[top] != x) {
            scc[sta[top]] = sccnt;
            top--;
        }
        scc[sta[top]] = sccnt;
        top--;
    }
}
void init(int n) {
    for (int i = 0; i <= (n + 1) * 2; i++) {
        g[i].y = 0;
        g[i].nxt = 0;
        head[i] = 0;
        dfn[i] = 0;
        low[i] = 0;
        scc[i] = 0;
        sta[i] = 0;
    }
    etot = 0;
    idx = 0;
    sccnt = 0;
    top = 0;
}
map<pair<int, int>, int> mpf;
void solve() {
    cin >> n >> m;
    init(n);
    for (int i = 1; i <= m; i++) {
        char sx, sy;
        int x, y;
        cin >> sx >> x >> sy >> y;
        x--;
        y--;
        x = x * 2 + (sx == 'h');
        y = y * 2 + (sy == 'h');
        add(x ^ 1, y);
        add(y ^ 1, x);
    }
    for (int i = 0; i < 2 * n; i++)
        if (!dfn[i]) tarjan(i);
    long long cntans = 0;
    for (int i = 0; i < n; i++)
        if (scc[i * 2] == scc[i * 2 + 1]) {
            cout << "BAD\n";
            return;
        }
    cout << "GOOD\n";
}
int main() {
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
}
```
